<!DOCTYPE html>
<!-- generated by gemini -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R2G Visualizer</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/dracula.min.css"> <!-- Example theme -->
    <style>
        /* Custom styles for Inter font and general layout */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f0f4f8; /* Light background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh; /* Full viewport height */
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1200px; /* Max width for content */
            width: 100%;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 24px;
        }
        .input-section {
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 16px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #f8fafc;
        }
        .canvas-section {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #f8fafc;
            overflow: hidden; /* Hide overflow if image is too big */
        }
        canvas {
            display: block;
            max-width: 100%; /* Ensure canvas is responsive */
            height: auto; /* Maintain aspect ratio */
            border-radius: 8px;
            background-color: #ffffff; /* White background for canvas */
        }
        /* CodeMirror specific styling adjustments */
        .CodeMirror {
            border: 1px solid #ddd;
            height: auto; /* Allow height to adjust to content */
            min-height: 300px; /* Minimum height for the editor */
            font-size: 14px;
            border-radius: 6px;
            overflow: hidden; /* Ensure rounded corners apply */
        }
        .CodeMirror-scroll {
            max-height: 400px; /* Max height before scrollbar appears */
        }
        /* Responsive adjustments */
        @media (min-width: 768px) {
            .container {
                flex-direction: row; /* Side-by-side on larger screens */
                justify-content: space-between;
                align-items: flex-start;
            }
            .input-section {
                flex: 1; /* Take available space */
                max-width: 400px; /* Max width for input controls */
            }
            .canvas-section {
                flex: 2; /* Take more space for canvas */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Input Section -->
        <div class="input-section">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">R2G Visualizer</h2>

            <!-- Image Upload -->
            <div>
                <label for="imageInput" class="block text-gray-700 text-sm font-semibold mb-2">Upload Image File:</label>
                <input type="file" id="imageInput" accept="image/*" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>

            <!-- JSON Data Input with CodeMirror -->
            <div>
                <label for="jsonEditor" class="block text-gray-700 text-sm font-semibold mb-2 mt-4">Paste JSON Data Here:</label>
                <textarea id="jsonEditor" class="hidden"></textarea> <!-- Hidden textarea for CodeMirror -->
                <div id="codeMirrorContainer" class="w-full"></div> <!-- CodeMirror will be initialized here -->
            </div>

            <!-- Offset Inputs -->
            <div class="flex flex-col gap-2 mt-4">
                <label class="block text-gray-700 text-sm font-semibold">Overlay Offset (pixels):</label>
                <div class="flex gap-4">
                    <div class="flex-1">
                        <label for="offsetX" class="block text-gray-600 text-xs mb-1">Offset X:</label>
                        <input type="number" id="offsetX" value="0" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div class="flex-1">
                        <label for="offsetY" class="block text-gray-600 text-xs mb-1">Offset Y:</label>
                        <input type="number" id="offsetY" value="0" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex flex-col gap-4 mt-4">
                <button id="loadDataBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75">
                    Load JSON Data
                </button>
                <button id="drawOverlayBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75">
                    Draw Overlay
                </button>
                <button id="clearCanvasBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75">
                    Clear Canvas
                </button>
            </div>
            <div id="messageBox" class="mt-4 p-3 bg-yellow-100 border border-yellow-400 text-yellow-700 rounded-md hidden" role="alert">
                <!-- Messages will be displayed here -->
            </div>
        </div>

        <!-- Canvas Section -->
        <div class="canvas-section">
            <canvas id="imageCanvas"></canvas>
        </div>
    </div>

    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/javascript/javascript.min.js"></script> <!-- JSON mode is part of JavaScript mode -->

    <script>
        // Get references to DOM elements
        const imageInput = document.getElementById('imageInput');
        const loadDataBtn = document.getElementById('loadDataBtn');
        const drawOverlayBtn = document.getElementById('drawOverlayBtn');
        const clearCanvasBtn = document.getElementById('clearCanvasBtn');
        const imageCanvas = document.getElementById('imageCanvas');
        const ctx = imageCanvas.getContext('2d');
        const messageBox = document.getElementById('messageBox');
        const offsetXInput = document.getElementById('offsetX');
        const offsetYInput = document.getElementById('offsetY');

        // Initialize CodeMirror editor
        const jsonEditor = CodeMirror(document.getElementById('codeMirrorContainer'), {
            mode: 'application/json', // Set mode to JSON for highlighting
            theme: 'dracula',         // Use the dracula theme (or any other available theme)
            lineNumbers: true,        // Show line numbers
            indentUnit: 2,            // Indent by 2 spaces
            tabSize: 2,               // Tab size of 2 spaces
            lineWrapping: true        // Wrap long lines
        });

        // Global variables to store image and parsed data
        let currentImage = null;
        let parsedData = null;

        // Define a color mapping for different room types
        const roomColors = {
            'no_type': '#808080',      // Grey
            'bedroom': '#FFDDC1',      // Light Peach
            'bathroom': '#B0E0E6',     // Powder Blue
            'closet': '#D3D3D3',       // Light Grey
            'kitchen': '#FFD700',      // Gold
            'living_room': '#98FB98',  // Pale Green
            'PS': '#DA70D6',           // Orchid
            'default': '#A9A9A9'       // Dark Grey for unknown types
        };

        /**
         * Displays a message in the message box.
         * @param {string} message The message to display.
         * @param {string} type The type of message (e.g., 'success', 'error', 'warning').
         */
        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.className = `mt-4 p-3 rounded-md block`; // Reset classes
            if (type === 'error') {
                messageBox.classList.add('bg-red-100', 'border-red-400', 'text-red-700');
            } else if (type === 'success') {
                messageBox.classList.add('bg-green-100', 'border-green-400', 'text-green-700');
            } else if (type === 'warning') {
                messageBox.classList.add('bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
            } else { // info
                messageBox.classList.add('bg-blue-100', 'border-blue-400', 'text-blue-700');
            }
            // Hide message after a few seconds
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 5000);
        }

        /**
         * Clears the canvas and resets global variables.
         */
        function clearCanvas() {
            ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            currentImage = null;
            parsedData = null;
            imageCanvas.width = 0;
            imageCanvas.height = 0;
            jsonEditor.setValue(''); // Clear CodeMirror content
            offsetXInput.value = '0'; // Reset offset inputs
            offsetYInput.value = '0'; // Reset offset inputs
            showMessage('Canvas cleared!', 'info');
        }

        /**
         * Handles image file selection and draws it on the canvas.
         * @param {Event} event The change event from the file input.
         */
        imageInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    // Set canvas dimensions to match image dimensions
                    imageCanvas.width = img.width;
                    imageCanvas.height = img.height;
                    ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height); // Clear before drawing new image
                    ctx.drawImage(img, 0, 0, img.width, img.height);
                    showMessage('Image loaded successfully!', 'success');
                };
                img.onerror = () => {
                    showMessage('Error loading image. Please ensure it is a valid image file.', 'error');
                    currentImage = null;
                };
                img.src = e.target.result;
            };
            reader.onerror = () => {
                showMessage('Error reading file.', 'error');
            };
            reader.readAsDataURL(file);
        });

        /**
         * Loads and parses JSON data from the CodeMirror editor.
         */
        loadDataBtn.addEventListener('click', () => {
            const jsonString = jsonEditor.getValue().trim(); // Get content from CodeMirror
            if (!jsonString) {
                showMessage('Please paste JSON data into the editor.', 'warning');
                parsedData = null;
                return;
            }

            try {
                parsedData = JSON.parse(jsonString);
                // Basic validation for required keys
                if (!parsedData.output_points || !parsedData.output_edges || !parsedData.rooms || typeof parsedData.scale_factor === 'undefined') {
                    showMessage('Invalid JSON format. Missing required keys (output_points, output_edges, rooms, scale_factor).', 'error');
                    parsedData = null;
                    return;
                }
                showMessage('JSON data loaded successfully!', 'success');
            } catch (error) {
                showMessage(`Error parsing JSON: ${error.message}. Please ensure it is valid JSON.`, 'error');
                parsedData = null;
            }
        });

        /**
         * Draws the overlay (points, edges, rooms) on the canvas.
         */
        drawOverlayBtn.addEventListener('click', () => {
            if (!currentImage) {
                showMessage('Please load an image first.', 'warning');
                return;
            }
            if (!parsedData) {
                showMessage('Please load JSON data first.', 'warning');
                return;
            }

            // Clear canvas and redraw image to ensure a clean slate for overlay
            ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            ctx.drawImage(currentImage, 0, 0, currentImage.width, currentImage.height);

            const scaleFactor = parsedData.scale_factor;
            const offsetX = parseFloat(offsetXInput.value) || 0;
            const offsetY = parseFloat(offsetYInput.value) || 0;

            /**
             * Scales coordinates from the normalized 512x512 space to the actual image dimensions.
             * The prompt states "coords are normalized to 512x512, so to undo use 1/scaling factor".
             * This implies that the 'scale_factor' in the JSON is the ratio by which original coordinates
             * were reduced to fit into the 512x512 normalized space (e.g., 512 / original_dimension).
             * To revert this normalization and get back to original image pixel coordinates, we divide
             * the normalized coordinate by this scale_factor.
             *
             * @param {number} coord The coordinate value from the JSON (normalized to 512x512).
             * @param {string} axis The axis ('x' or 'y') to apply the offset.
             * @returns {number} The scaled coordinate for the actual image, with optional offset applied.
             */
            const scaleCoord = (coord, axis) => {
                let scaled = coord / scaleFactor;
                if (axis === 'x') {
                    scaled += offsetX;
                } else if (axis === 'y') {
                    scaled += offsetY;
                }
                return scaled;
            };

            // 1. Draw Output Points
            if (parsedData.output_points && Array.isArray(parsedData.output_points)) {
                parsedData.output_points.forEach(point => {
                    const x = scaleCoord(point[0], 'x');
                    const y = scaleCoord(point[1], 'y');
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2); // Draw a circle with radius 5
                    ctx.fillStyle = 'red'; // Red color for points
                    ctx.fill();
                    ctx.closePath();
                });
                showMessage(`Drew ${parsedData.output_points.length} points.`, 'info');
            }

            // 2. Draw Output Edges
            if (parsedData.output_edges && Array.isArray(parsedData.output_edges)) {
                parsedData.output_edges.forEach(edge => {
                    const p1 = edge[0];
                    const p2 = edge[1];
                    const x1 = scaleCoord(p1[0], 'x');
                    const y1 = scaleCoord(p1[1], 'y');
                    const x2 = scaleCoord(p2[0], 'x');
                    const y2 = scaleCoord(p2[1], 'y');

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = 'blue'; // Blue color for edges
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.closePath();
                });
                showMessage(`Drew ${parsedData.output_edges.length} edges.`, 'info');
            }

            // 3. Draw Rooms (Polygons)
            if (parsedData.rooms && Array.isArray(parsedData.rooms)) {
                parsedData.rooms.forEach(room => {
                    if (room.room_junctions && Array.isArray(room.room_junctions) && room.room_junctions.length > 1) {
                        const color = roomColors[room.semantic] || roomColors['default'];
                        ctx.beginPath();
                        
                        // Move to the first point
                        const firstPoint = room.room_junctions[0];
                        ctx.moveTo(scaleCoord(firstPoint.x, 'x'), scaleCoord(firstPoint.y, 'y'));

                        // Draw lines to subsequent points
                        for (let i = 1; i < room.room_junctions.length; i++) {
                            const nextPoint = room.room_junctions[i];
                            ctx.lineTo(scaleCoord(nextPoint.x, 'x'), scaleCoord(nextPoint.y, 'y'));
                        }

                        // Close the path by drawing a line back to the first point
                        ctx.closePath();

                        ctx.strokeStyle = color;
                        ctx.lineWidth = 3; // Thicker lines for rooms
                        ctx.stroke();

                        // Optionally fill the room with a transparent color
                        ctx.fillStyle = `${color}33`; // Add transparency (e.g., 20% opacity)
                        ctx.fill();
                    }
                });
                showMessage(`Drew ${parsedData.rooms.length} rooms.`, 'info');
            }
            showMessage('Overlay drawn successfully!', 'success');
        });

        // Clear canvas button event listener
        clearCanvasBtn.addEventListener('click', clearCanvas);

        // Initial message on load
        window.onload = () => {
            showMessage('Welcome! Load an image and JSON data to begin.', 'info');
        };

    </script>
</body>
</html>
